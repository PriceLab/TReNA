<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>A Brief Introduction to TReNA • trena</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="A Brief Introduction to TReNA">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">trena</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.7.12</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/TReNA_Vignette.html">A Brief Introduction to TReNA</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>A Brief Introduction to TReNA</h1>
            
      
      
      <div class="hidden name"><code>TReNA_Vignette.Rmd</code></div>

    </div>

    
    
<div id="overview-of-trena" class="section level2">
<h2 class="hasAnchor">
<a href="#overview-of-trena" class="anchor"></a>Overview of TReNA</h2>
<p>TReNA is a package for inferring relationships between target genes and their candidate regulators. By using TReNA, we can generate hypotheses around regulation of gene expression and enable the construction of gene network models. In the most basic sense, TReNA provides two operations using the data. First, it filters putitive transcriptional regulators based on user-specified criteria, such as presence of motifs or footprints. Second, given a matrix of gene expression data (that must include the expression levels of transcription factors), a target gene, and list of candidate regulators as predictors, it uses a user-specified solver to perform feature selection. Thus, the standard TReNA workflow is the following:</p>
<ol style="list-style-type: decimal">
<li>Select an expression matrix (RNA-seq or microarray) of interest.</li>
<li>Use one of the built-in filtering methods to determine your set of candidate regulators.</li>
<li>Use one of the built-in solver methods to perform feature selection, identifying putative transcriptional regulators for the target gene.</li>
</ol>
<p>The filtering step, while technically optional, can constrain the solution space and reduce computational time by reducing the number of predictors supplied to the solver. Rather than supplying hundreds of transcription factors that can obscure meaningful relationships between genes, filters allow the user to screen out less likely candidates, leaving only the most likely affectors.</p>
<p>Starting off, we’ll load the TReNA library.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span>(trena)</code></pre></div>
</div>
<div id="selecting-an-expression-matrix" class="section level2">
<h2 class="hasAnchor">
<a href="#selecting-an-expression-matrix" class="anchor"></a>Selecting an Expression Matrix</h2>
<p>Running the solvers in TReNA requires a matrix of gene expression data; there are several example data sets included with the TReNA package. In this case, we will load data from a study on Alzheimer’s disease (Nat Sci Data, <a href="doi:10.1038/sdata.2016.89" class="uri">doi:10.1038/sdata.2016.89</a>), in which 278 samples were obtained for 154 transcription factors.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://rdrr.io/r/base/load.html">load</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span>(<span class="dt">package=</span><span class="st">"trena"</span>, <span class="st">"extdata/ampAD.154genes.mef2cTFs.278samples.RData"</span>))</code></pre></div>
<p>This gives us a matrix, <code>mtx.sub</code>, that contains our gene expression data in units of TMM. Before proceeding further , it is wise to inspect the distribution of the matrix and consider using some sort of data transformation to normalize the mean-variance relationship. We can see, for instance, that our dataset is fairly skewed, with most of the expression values falling close to 0 and only a few values on the higher end of the spectrum.</p>
<p><img src="TReNA_Vignette_files/figure-html/unnamed-chunk-3-1.png" width="576"></p>
<p>The skewed nature of the matrix may profoundly affect our results. To overcome this, we will transform our matrix using the hyperbolic arcsine (<code>asinh</code>) function</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtx.asinh &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/Hyperbolic.html">asinh</a></span>(mtx.sub)</code></pre></div>
<p>If we now plot our transformed matrix, we can see that it’s been scaled down substantially.</p>
<p><img src="TReNA_Vignette_files/figure-html/unnamed-chunk-5-1.png" width="576"></p>
<p>In general, we recommend a transformation of this nature to adjust skewed data. The <code>voom</code> transformation or something similar (e.g. <code><a href="https://rdrr.io/r/base/Hyperbolic.html">asinh()</a></code>) adjusts the mean-variance relationship and can greatly change the results we see. Moving forward, we will use this transformed data set in the rest of our analyses.</p>
</div>
<div id="basic-interface-the-trena-class" class="section level2">
<h2 class="hasAnchor">
<a href="#basic-interface-the-trena-class" class="anchor"></a>Basic Interface: The <code>Trena</code> Class</h2>
<p>The most straightforward way to filter candidates and perform feature selection is by constructing a <code>Trena</code> object.</p>
</div>
<div id="filtering-candidate-regulators" class="section level2">
<h2 class="hasAnchor">
<a href="#filtering-candidate-regulators" class="anchor"></a>Filtering Candidate Regulators</h2>
<p>TReNA currently supports 4 different candidate transcription factor inputs, all of which are subclasses of the <code>CandidateFilter</code> class:</p>
<ol style="list-style-type: decimal">
<li>
<code>VarianceFilter</code>: returns transcription factors with expression variance within a certain range of the target gene’s expression variance</li>
<li>
<code>GeneOntologyFilter</code>: given an organism database and a Gene Ontology term (GOterm), returns only those genes that match the GOterm</li>
<li>
<code>HumanDHSFilter</code>: given a genome database, DNAse hypersensitivity (DHS) database, and region specifications, return only those genes that fall within the given region</li>
<li>
<code>FootprintFilter</code>: using a PostgreSQL or SQLite database of footprint data, returns transcription factors with footprints for a given target gene for a specified genomic range</li>
</ol>
<p>In order to get a list of transcription factor candidates, you must construct the appropriate object by supplying the necessary parameters for that <code>CandidateFilter</code>, then call the <code><a href="../reference/getCandidates.html">getCandidates()</a></code> method on the candidate inputs. In each case, the call to <code><a href="../reference/getCandidates.html">getCandidates()</a></code> is identical and operates on only the <code>CandidateFilter</code> object.</p>
<div id="the-variancefilter-subclass" class="section level3">
<h3 class="hasAnchor">
<a href="#the-variancefilter-subclass" class="anchor"></a>The <code>VarianceFilter</code> Subclass</h3>
<p>The <code>VarianceFilter</code> requires the specification of the expression matrix and a target gene, plus it allows you to optionally specify a variance size range. It finds the variance of all genes in the assay matrix, then returns all transcription factors with variance within the variance size range of the target gene. For instance, we can create a VarianceFilter and use it to find all transcription factors with variance within 50% of the target gene’s variance. This will return a named list with both the names of the transcription factors and their variances.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">variance.filter &lt;-<span class="st"> </span><span class="kw"><a href="../reference/VarianceFilter-class.html">VarianceFilter</a></span>(<span class="dt">mtx.assay =</span> mtx.asinh, <span class="dt">targetGene =</span> <span class="st">"MEF2C"</span>, <span class="dt">varSize =</span> <span class="fl">0.5</span>)
tf.list &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getCandidates.html">getCandidates</a></span>(variance.filter)
<span class="kw"><a href="https://rdrr.io/r/utils/str.html">str</a></span>(tf.list)</code></pre></div>
<pre><code>## List of 2
##  $ tfs    : chr [1:36] "BCL6" "BCL6B" "CREB5" "CUX2" ...
##  $ tf.vars: Named num [1:36] 0.23 0.479 0.28 0.501 0.248 ...
##   ..- attr(*, "names")= chr [1:36] "BCL6" "BCL6B" "CREB5" "CUX2" ...</code></pre>
</div>
<div id="the-geneontologyfilter-subclass" class="section level3">
<h3 class="hasAnchor">
<a href="#the-geneontologyfilter-subclass" class="anchor"></a>The <code>GeneOntologyFilter</code> Subclass</h3>
<p>The</p>
</div>
<div id="the-footprintfilter-subclass" class="section level3">
<h3 class="hasAnchor">
<a href="#the-footprintfilter-subclass" class="anchor"></a>The <code>FootprintFilter</code> Subclass</h3>
<p>The most complex filter is the FootprintFilter, which leverages information from footprint databases in either SQLite or PostgreSQL. This input requires connection to 2 databases: 1) A genome database, which contains information on the location and function of genes; 2) A project database, which contains footprint regions from a specific project. As an illustration of the format and utility of these databases, we have included in <code>extdata</code> two SQLite databases demonstrating the required tables and information needed to use the FootprintFilter. Our databases are subsets of larger databases, corresponding to the <em>MEF2C</em> gene and a footprinting project in the brain using the Wellington method for determining footprints.</p>
<p>In addition to the databases, constructing a FootprintFilter object requires a data frame of regions to look in for footprints. When the <code>getCandidates</code> method is run, the <code>FootprintFilter</code> returns a dataframe containing the footprints in the supplied regions, including the names of motifs for those footprints.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Sp</span>
db.address &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span>(<span class="dt">package=</span><span class="st">"trena"</span>, <span class="st">"extdata"</span>)
genome.db.uri &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"sqlite:/"</span>,db.address,<span class="st">"mef2c.neighborhood.hg38.gtfAnnotation.db"</span>, <span class="dt">sep =</span> <span class="st">"/"</span>)
project.db.uri &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"sqlite:/"</span>,db.address,<span class="st">"mef2c.neigborhood.hg38.footprints.db"</span>, <span class="dt">sep =</span> <span class="st">"/"</span>)

<span class="co"># Create the specs for the MEF2C gene region</span>
tss &lt;-<span class="st"> </span><span class="dv">88904257</span>
start &lt;-<span class="st"> </span>tss <span class="op">-</span><span class="st"> </span><span class="dv">1000</span>
end &lt;-<span class="st"> </span>tss <span class="op">+</span><span class="st"> </span><span class="dv">1000</span>
chrom &lt;-<span class="st"> "chr5"</span>
gene.regions &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(<span class="dt">chrom=</span>chrom,
                           <span class="dt">start=</span>start,
                           <span class="dt">end=</span>end,
                           <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)

<span class="co"># Create a filter using the geneCenteredSpec option</span>
footprint.filter &lt;-<span class="st"> </span><span class="kw"><a href="../reference/FootprintFilter-class.html">FootprintFilter</a></span>(<span class="dt">genomeDB =</span> genome.db.uri, <span class="dt">footprintDB =</span> project.db.uri,
<span class="dt">regions =</span> gene.regions)

<span class="co"># Run the getCandidates method</span>
tbl &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getCandidates.html">getCandidates</a></span>(footprint.filter)[[<span class="dv">1</span>]]
<span class="kw"><a href="https://rdrr.io/r/utils/str.html">str</a></span>(tbl)</code></pre></div>
<pre><code>## 'data.frame':    142 obs. of  19 variables:
##  $ loc       : chr  "chr5:88903266-88903276" "chr5:88903286-88903306" "chr5:88903292-88903305" "chr5:88903293-88903321" ...
##  $ chrom     : chr  "chr5" "chr5" "chr5" "chr5" ...
##  $ start     : int  88903266 88903286 88903292 88903293 88903296 88903301 88903301 88903302 88903302 88903304 ...
##  $ endpos    : int  88903276 88903306 88903305 88903321 88903313 88903315 88903317 88903314 88903314 88903316 ...
##  $ fp_start  : int  88903247 88903303 88903303 88903303 88903303 88903303 88903303 88903303 88903303 88903303 ...
##  $ fp_end    : int  88903270 88903328 88903328 88903328 88903328 88903328 88903328 88903328 88903328 88903328 ...
##  $ type      : chr  "motif.in.footprint" "motif.in.footprint" "motif.in.footprint" "motif.in.footprint" ...
##  $ motifName : chr  "NA-SwissRegulon-FOXN1.SwissRegulon" "Scerevisiae-UniPROBE-Sfp1.UP00342" "Mmusculus-jaspar2016-Arid5a-MA0602.1" "NA-SwissRegulon-ZBTB16.SwissRegulon" ...
##  $ length    : int  11 21 14 29 18 15 17 13 13 13 ...
##  $ strand    : chr  "+" "+" "+" "-" ...
##  $ sample_id : chr  "ENCSR000DBW" "ENCSR318PRQ" "ENCSR318PRQ" "ENCSR318PRQ" ...
##  $ method    : chr  "WELLINGTON" "WELLINGTON" "WELLINGTON" "WELLINGTON" ...
##  $ provenance: chr  "brain_wellington_20.minid" "brain_wellington_20.minid" "brain_wellington_20.minid" "brain_wellington_20.minid" ...
##  $ score1    : num  -4.73 -23.15 -23.15 -23.15 -23.15 ...
##  $ score2    : num  11.13 11.7 10.75 9.65 10.51 ...
##  $ score3    : num  8.86e-05 3.77e-05 9.27e-05 6.97e-05 8.39e-05 6.91e-05 4.58e-05 4.22e-06 4.22e-06 9.15e-05 ...
##  $ score4    : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ score5    : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ score6    : num  NA NA NA NA NA NA NA NA NA NA ...</code></pre>
<p>A FootprintFilter will only retrieve footprints and their motifs; to associate these motifs with transcription factors, we recommend using the MotifDb package, which is already required for trena. The <code>associateTranscriptionFactors</code> adds the transcription factors, which can then be used later as candidate regulators. To do this, we’ll just have to change the name of the motif column from <code>name</code> to <code>motifName</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span>(MotifDb)

tbl.tfs &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/pkg/MotifDb/man/associateTranscriptionFactors.html">associateTranscriptionFactors</a></span>(MotifDb, tbl, <span class="dt">source=</span><span class="st">"MotifDb"</span>, <span class="dt">expand.rows=</span><span class="ot">TRUE</span>)
<span class="kw"><a href="https://rdrr.io/r/utils/str.html">str</a></span>(tbl.tfs)</code></pre></div>
<pre><code>## 'data.frame':    151 obs. of  23 variables:
##  $ motifName : chr  "Ggallus-jaspar2016-LIN54-MA0619.1" "Hsapiens-HOCOMOCOv10-ARI3A_HUMAN.H10MO.D" "Hsapiens-HOCOMOCOv10-ARI3A_HUMAN.H10MO.D" "Hsapiens-HOCOMOCOv10-ARI3A_HUMAN.H10MO.D" ...
##  $ loc       : chr  "chr5:88903373-88903381" "chr5:88903368-88903389" "chr5:88903305-88903326" "chr5:88903334-88903355" ...
##  $ chrom     : chr  "chr5" "chr5" "chr5" "chr5" ...
##  $ start     : int  88903373 88903368 88903305 88903334 88903311 88903308 88903311 88903308 88903351 88903377 ...
##  $ endpos    : int  88903381 88903389 88903326 88903355 88903327 88903324 88903327 88903317 88903360 88903390 ...
##  $ fp_start  : int  88903378 88903378 88903303 88903327 88903327 88903303 88903303 88903303 88903327 88903378 ...
##  $ fp_end    : int  88903403 88903403 88903328 88903352 88903352 88903328 88903328 88903328 88903352 88903403 ...
##  $ type      : chr  "motif.in.footprint" "motif.in.footprint" "motif.in.footprint" "motif.in.footprint" ...
##  $ length    : int  9 22 22 22 17 17 17 10 10 14 ...
##  $ strand    : chr  "+" "-" "+" "-" ...
##  $ sample_id : chr  "ENCSR318PRQ" "ENCSR318PRQ" "ENCSR318PRQ" "ENCSR000DBW" ...
##  $ method    : chr  "WELLINGTON" "WELLINGTON" "WELLINGTON" "WELLINGTON" ...
##  $ provenance: chr  "brain_wellington_20.minid" "brain_wellington_20.minid" "brain_wellington_20.minid" "brain_wellington_20.minid" ...
##  $ score1    : num  -25.9 -25.9 -23.1 -9.6 -9.6 ...
##  $ score2    : num  11.35 16.76 8.93 16.46 11.01 ...
##  $ score3    : num  9.18e-05 1.18e-06 8.28e-05 1.47e-06 1.53e-05 2.87e-05 1.53e-05 7.87e-05 7.87e-05 3.79e-05 ...
##  $ score4    : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ score5    : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ score6    : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ geneSymbol: chr  "LIN54" "ARI3A" "ARI3A" "ARI3A" ...
##  $ pubmedID  : chr  "24194598" "26586801" "26586801" "26586801" ...
##  $ organism  : chr  "Ggallus" "Hsapiens" "Hsapiens" "Hsapiens" ...
##  $ source    : chr  "MotifDb" "MotifDb" "MotifDb" "MotifDb" ...</code></pre>
<p>The FootprintFilter supports use of either PostgreSQL and SQLite databases in a specific 2-table schema. In the previous example, we used an SQLite database included in the package; essentially a small snapshot of a larger dataset. More usefully, there are now publically available databases of footprints for use at <code>bddsrds.globusgenomics.org</code>. For an updated table of these databases, please refer to <a href="https://github.com/PriceLab/TReNA">trena.org</a>.</p>
</div>
</div>
<div id="feature-selection-the-solver-object" class="section level2">
<h2 class="hasAnchor">
<a href="#feature-selection-the-solver-object" class="anchor"></a>Feature Selection: the <code>Solver</code> Object</h2>
<p>Once you know your candidate regulators and you’ve got a target gene in mind, you’re ready to construct a <code>Solver</code> object. A <code>Solver</code> object is a construct that contains the expression matrix, candidate regulators, target gene, and a solver method of choice. . TReNA currently supports 9 different solvers. Their associated solvers strings for use in TReNA are (in no particular order):</p>
<ol style="list-style-type: decimal">
<li>LassoSolver - an application of <code>glmnet</code> using <code>alpha = 0.9</code> as the default elastic net parameter</li>
<li>RidgeSolver - an application of <code>glmnet</code> using <code>alpha = 0</code> as the default elastic net parameter</li>
<li>RandomForestSolver - an application of `randomForest*, the standard Random Forest function</li>
<li>BayesSpikeSolver - an application of <code>vbsr</code>, the Bayes Spike function from the <code>vbsr</code> package</li>
<li>SqrtLassoSolver - an application of the <code>slim</code> function from the <code>flare</code> package, with <code>q = 2</code>
</li>
<li>LassoPVSolver - an application of <code>lassopv</code>, the P-Value LASSO function</li>
<li>PearsonSolver - an application of the <code>cor</code> function using the default parameters</li>
<li>SpearmanSolver - an application of the <code>cor</code> function using <code>method = "spearman"</code>
</li>
<li>EnsembleSolver - a combination of 2 or more of the other solvers; by default, it uses all but <code>BayesSpikeSolver</code> and <code>SqrtLassoSolver</code>
</li>
</ol>
<p>When it comes to selecting a solver, we recommend doing some critical thinking about which solver most suits your purposes before choosing. Each of solvers has its own strengths and weaknesses that we will not delve into here, but that are generally detailed within their own packages. To begin with, we will use the LassoSolver, which uses LASSO regularlized regression to select features. Once a solver has been chosen, the particular <code>Solver</code> object is simply specified:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lasso.solver &lt;-<span class="st"> </span><span class="kw"><a href="../reference/LassoSolver.html">LassoSolver</a></span>(<span class="dt">mtx.assay =</span> mtx.asinh,
                            <span class="dt">targetGene =</span> <span class="st">"MEF2C"</span>,
                            <span class="dt">candidateRegulators =</span> tbl.tfs<span class="op">$</span>geneSymbol
                            )</code></pre></div>
<p>We have now created an object of the <code>LassoSolver</code> class, which in this case uses <em>“MEF2C”</em> as the target gene and the candidate regulators we found using the <code>FootprintFilter</code> above. Regardless of the specific subclass, any <code>Solver</code> object can be executed using the <code>run</code> command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="dv">10</span>)
tbl &lt;-<span class="st"> </span><span class="kw"><a href="../reference/run.html">run</a></span>(lasso.solver)
<span class="kw"><a href="https://rdrr.io/r/utils/str.html">str</a></span>(tbl)</code></pre></div>
<pre><code>## 'data.frame':    6 obs. of  2 variables:
##  $ beta     : num  1.215 -0.471 -0.325 -0.323 -0.211 ...
##  $ intercept: num  2.1 2.1 2.1 2.1 2.1 ...</code></pre>
<p>The output of each <code>run</code> method can vary with solver type, but in general it will return the coefficients for each feature, in this case contained in the <code>beta</code> field. Notably, the <code>LassoSolver</code>, <code>SqrtLassoSolver</code>, and <code>EnsembleSolver</code> often return subsets of the supplied candidate regulators, whereas the remaining methods return coefficients for all regulators. This behavior can be tuned as well; for instance, we can alter the <code>LassoSolver</code> object by adjusting <code>lambda</code>, a tuning parameter that corresponds to the penalty imposed on regression coefficients.</p>
<p>First, we will alter a different parameter of the <code>LassoSolver</code> object, the <code>keep.metrics</code> parameter. This optional Boolean argument will return several parameters of the fit if specified as <code>TRUE</code> (default = FALSE), including the <code>lambda</code> value determined via permutation testing. We can see this behavior by creating and running this new <code>LassoSolver</code> object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="dv">10</span>)
lasso.solver.keep &lt;-<span class="st"> </span><span class="kw"><a href="../reference/LassoSolver.html">LassoSolver</a></span>(<span class="dt">mtx.assay =</span> mtx.asinh,
                                 <span class="dt">targetGene =</span> <span class="st">"MEF2C"</span>,
                                 <span class="dt">candidateRegulators =</span> tbl.tfs<span class="op">$</span>geneSymbol,
                                 <span class="dt">keep.metrics =</span> <span class="ot">TRUE</span>
                                 )
tbl.keep &lt;-<span class="st"> </span><span class="kw"><a href="../reference/run.html">run</a></span>(lasso.solver.keep)
<span class="kw"><a href="https://rdrr.io/r/utils/str.html">str</a></span>(tbl.keep)</code></pre></div>
<pre><code>## List of 3
##  $ mtx.beta:'data.frame':    6 obs. of  2 variables:
##   ..$ beta     : num [1:6] 1.215 -0.471 -0.325 -0.323 -0.211 ...
##   ..$ intercept: num [1:6] 2.1 2.1 2.1 2.1 2.1 ...
##  $ lambda  : num 0.0541
##  $ r2      : Named num 0.648
##   ..- attr(*, "names")= chr "1"</code></pre>
<p>As shown, we now get a list where the first element is our data frame from the previous example, the second is the value determined for <code>lambda</code>, and the final element is the value determined for <span class="math inline">\(r^{2}\)</span>. Notably, the <code>keep.metrics</code> argument is only available for the <code>LassoSolver</code> and <code>RidgeSolver</code> objects at this time.</p>
<p>Now we can change the value of <code>lambda</code> to change how many features are returned by the solver. In this case, we’ll make <code>lambda</code> much smaller; this will relax the penalty imposed on regression coefficients, thus we expect to get more features returned to us:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lasso.solver.lenient  &lt;-<span class="st"> </span><span class="kw"><a href="../reference/LassoSolver.html">LassoSolver</a></span>(<span class="dt">mtx.assay =</span> mtx.asinh,
                                     <span class="dt">targetGene =</span> <span class="st">"MEF2C"</span>,
                                     <span class="dt">candidateRegulators =</span> tbl.tfs<span class="op">$</span>geneSymbol,
                                     <span class="dt">lambda =</span> <span class="fl">0.05</span>
                                     )
tbl.lenient &lt;-<span class="st"> </span><span class="kw"><a href="../reference/run.html">run</a></span>(lasso.solver.lenient)
<span class="kw"><a href="https://rdrr.io/r/utils/str.html">str</a></span>(tbl.lenient)</code></pre></div>
<pre><code>## 'data.frame':    6 obs. of  2 variables:
##  $ beta     : num  1.228 -0.484 -0.328 -0.326 -0.22 ...
##  $ intercept: num  2.02 2.02 2.02 2.02 2.02 ...</code></pre>
<p>As expected, we get nearly twice as many features as in our original example. Different <code>Solver</code> subclasses have different optional arguments corresponding to their specific solver methods. For more information on <code>Solver</code> object, check the documentation for your object of interest; for more information on a particular solver method, check the original package referenced in the help documentation for that <code>Solver</code> object.</p>
<p>Each solver will necessarily give a different result, neccessitating some amount of thoughtfulness on the part of the user. For instance, if the goal is to return a sparse list of only the most influential genes, then LASSO may be the best choice. By contrast, using the Random Forest method will return scores for all genes, and will thus result in inferring more relationships.</p>
</div>
<div id="using-an-ensemble-solver-approach" class="section level2">
<h2 class="hasAnchor">
<a href="#using-an-ensemble-solver-approach" class="anchor"></a>Using an Ensemble Solver Approach</h2>
<p>In addition to the individual solvers, TReNA includes an ensemble approach as a solver option. The <code>EnsembleSolver</code> class allows the user to specify a vector of multiple TReNA solvers as part of the argument list (e.g. <code>solverNames = c("lasso","ridge")</code>). Alternatively, the user can leave this argument unspecified to run all solvers but Bayes Spike and square root LASSO (the most sensitive to outliers and the computationally intensive, respectively). Other solver-specific parameters may also be specified, such as the <code>lambda</code> value for LASSO; these additional arguments can be found in the help documentation for the <code>EnsembleSolver</code></p>
<p>The <code>EnsembleSolver</code> also has a <code>geneCutoff</code> argument, whereby the <code>run</code> method cuts off a certain fraction of the total regulators supplied. For example, if 200 candidates are supplied and the <code>geneCutoff</code> is left at its default value (default = 0.1), only roughly 20 genes will be returned in the final data frame. The <code>geneCutoff</code> argument is designed to help the user hone in on only the most important features in a model, but it can be changed to 100% of the features if so desired. In cases of smaller sets of regulators, the cutoff will cease being imposed once the number of features drops below 10.</p>
<p>Besides computing and returning the individual scores of each solver, the ensemble solver generates an “extreme” score (<code>pcaMax</code>) and a “concordance” score (<code>concordance</code>) based on all solvers. Both of these new scores are computed using a principle component analysis on all individual solver scores and can perhaps best be understood as follows:</p>
<ul>
<li><p><code>pcaMax</code> essentially quantifies the extent to which dissimilar solvers agree on selecting a given feature. For instance, if Random Forest and LASSO both deem a particular feature important, then it is likely to have a high <code>pcaMax</code> score. By contrast, if Pearson and Spearman both deem a feature important, it would be less likely to have a high <code>pcaMax</code> score because the methods are quite similar to one another. The basic idea here is that if lots of dissimilar methods agree on the importance of a feature, it is more likely to actually be important.</p></li>
<li><p><code>concordance</code> essentially weighs each solver equally and sums up the contributions from each one, regardless of method similarity. Thus, if Random Forst and LASSO both deem a particular feature important, it is equally likely to have a high <code>concordance</code> score as if Pearson and Spearman both deem a feature important. This score functions as more of a basic “voting” system of which solves consider a feature significant and ranges from 0-1.</p></li>
</ul>
<p>We can see this in action by constructing and running an <code>EnsembleSolver</code> object with the default arguments for <code>solverNames</code> and <code>geneCutoff</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ensemble.solver &lt;-<span class="st"> </span><span class="kw"><a href="../reference/EnsembleSolver.html">EnsembleSolver</a></span>(<span class="dt">mtx.assay =</span> mtx.asinh, 
                                  <span class="dt">targetGene =</span> <span class="st">"MEF2C"</span>,
                                  <span class="dt">candidateRegulators =</span> tbl.tfs<span class="op">$</span>geneSymbol)
tbl.out &lt;-<span class="st"> </span><span class="kw"><a href="../reference/run.html">run</a></span>(ensemble.solver)
tbl.out</code></pre></div>
<pre><code>##     gene   betaLasso  lassoPValue pearsonCoeff   rfScore   betaRidge
## 1  FOXD2 -0.21708114 1.445129e-10  -0.33079230 13.416248 -0.16284694
## 2  FOXL1  0.00000000 1.715744e-01  -0.28854381  4.612113 -0.17832725
## 3  FOXO3  1.22390420 8.835747e-29   0.60182289 25.151960  0.81914024
## 4   LHX2  0.02875834 1.441601e-02   0.03071925 13.342908  0.04436311
## 5 POU4F1 -0.48012027 1.207097e-13  -0.45072667  9.667694 -0.49447608
## 6   SOX1  0.00000000 3.560877e-01   0.21491204  8.273583  0.10123560
## 7   SOX8 -0.32501563 3.743920e-24  -0.56932686 19.063225 -0.25916229
## 8   VSX1 -0.32711191 5.434800e-19  -0.48616195 14.473402 -0.25193017
##   spearmanCoeff    xgboost
## 1   -0.50926699 0.17490724
## 2   -0.28923902 0.02412531
## 3    0.66974449 0.27799407
## 4   -0.31090302 0.13903451
## 5   -0.44340246 0.05544559
## 6    0.06231521 0.05501908
## 7   -0.61869917 0.19198925
## 8   -0.47833418 0.08148496</code></pre>
<p>Note that in the final data frame, regulators are returned in descending order of <code>pcaMax</code> score. If we so choose, we can change the <code>solverNames</code> and <code>geneCutoff</code> as well; for this example, we’ll change them to just 4 solver methods and 100% of the genes, respectively:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ensemble.full &lt;-<span class="st"> </span><span class="kw"><a href="../reference/EnsembleSolver.html">EnsembleSolver</a></span>(<span class="dt">mtx.assay =</span> mtx.asinh,
                                <span class="dt">targetGene =</span> <span class="st">"MEF2C"</span>,
                                <span class="dt">candidateRegulators =</span> tbl.tfs<span class="op">$</span>geneSymbol,
                                <span class="dt">solverNames =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"lasso"</span>,<span class="st">"pearson"</span>,<span class="st">"randomforest"</span>,<span class="st">"ridge"</span>),
                                <span class="dt">geneCutoff =</span> <span class="dv">1</span>
                                )
tbl.full &lt;-<span class="st"> </span><span class="kw"><a href="../reference/run.html">run</a></span>(ensemble.full)
<span class="kw"><a href="https://rdrr.io/r/utils/str.html">str</a></span>(tbl.full)</code></pre></div>
<pre><code>## 'data.frame':    8 obs. of  5 variables:
##  $ gene        : chr  "FOXD2" "FOXL1" "FOXO3" "LHX2" ...
##  $ betaLasso   : num  -0.19897 0 1.1962 0.00717 -0.45283 ...
##  $ pearsonCoeff: num  -0.3308 -0.2885 0.6018 0.0307 -0.4507 ...
##  $ rfScore     : num  12.75 4.79 25.63 12.74 9.57 ...
##  $ betaRidge   : num  -0.1711 -0.18 0.8533 0.0487 -0.5109 ...</code></pre>
<p>As demonstrated, the full set of regulators here is 64; when using a 10% cutoff, we only get 9 features in the final model as the cutoff is designed to go into effect only for 10 or more features.</p>
<p>The ensemble approach is an attractive option for a couple of reasons:</p>
<ol style="list-style-type: decimal">
<li><p>Solver choice can be a non-trivial task for a TReNA user, as it requires some working knowledge of the pros and cons of the different methods. The ensemble method alleviates the need to choose one solver.</p></li>
<li><p>Different solvers will give different predictions for important transcription factors; the ensemble method provides a way to create a composite score that accounts for all included solvers and can thus be seen as something of an overall metric.</p></li>
<li><p>The relationship between transcription factors and target genes is a young area of active investigation. How this relates to the various solvers is an open question. TReNA was born out of a desire to explore these relationships.</p></li>
</ol>
<p>Thus, if you are a first-time TReNA user, we recommend that you start with the <code>EnsembleSolver</code> as your <code>Solver</code> object of choice.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">

        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#overview-of-trena">Overview of TReNA</a></li>
      <li><a href="#selecting-an-expression-matrix">Selecting an Expression Matrix</a></li>
      <li><a href="#basic-interface-the-trena-class">Basic Interface: The <code>Trena</code> Class</a></li>
      <li><a href="#filtering-candidate-regulators">Filtering Candidate Regulators</a></li>
      <li><a href="#feature-selection-the-solver-object">Feature Selection: the <code>Solver</code> Object</a></li>
      <li><a href="#using-an-ensemble-solver-approach">Using an Ensemble Solver Approach</a></li>
      </ul>
</div>
      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by Paul Shannon.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
